# O valor da fun√ß√£o1 retorna 20 e o valor da fun√ß√£o global retorna 10, por mais que a fun√ß√£o chame a fun√ß√£o 1 e tenha a mesma vari√°vel

a √© GLOBAL 

def funcao1 ():
    a = 20
    print("print dentro da funcao1: ")
    print(a)

a = 10
funcao1()
print("print dentro do corpo principal: ")
print(a)

# Nesse exemplo ir√° retornar 20 nos dois PRINT, pois agora foi declarado "a" como GLOBAL na primeira fun√ß√£o

def funcao1 ():
    global a 
    a = 20
    print("print dentro da funcao1: ")
    print(a)

a = 10
funcao1()
print("print dentro do corpo principal: ")
print(a)

#visualizar n√∫meros com muitos d√≠gitos  underline (_), para O tipo int conjunto dos inteiros (Z) 
type(1_000_000) 
<class 'int'>

#float √© usado para elementos do conjunto dos reais (R), devemos usar o ponto e n√£o virgula
type(50.0)
<class 'float'>

# Ao usar a v√≠rgula como separador 
50, 0
(50, 0)

# Divis√£o inteira = "// 

# Divis√£o com resto = "%" 

#complex para manipular n√∫meros complexos na forma x + yj 
r = complex(2,5)
r
(2+5j)

w=2+5j 
type (w)
<class 'complex'>

#r.conjugate() retorna o conjugado do n√∫mero complexo r, em que a parte real √© mantida e a parte imagin√°ria tem o seu sinal trocado.

#tipo bool, express√µes booleanas.True ou False 
2>3
False
2<3
True
#Operador NOT / True, not(valor) ter√° o valor False 
not (2<3)
False

# Simbolos matematicos
Soma	+ 
Subtra√ß√£o	-
Multiplica√ß√£o	*
Divis√£o	/
Divis√£o inteira	//
Resto na divis√£o inteira	%
Valor absoluto	abs(par√¢metro)
Exponencia√ß√£o	**
<	Menor que
<=	Menor ou igual a
>	Maior que
>=	Maior ou igual a
==	Igual
!=	N√£o igual


# UPPER Transforma todas as letras em mai√∫sculas
curso = 'Ensino a Dist√¢ncia'
curso.upper()
'ENSINO A DIST√ÇNCIA'

#LOWER letras minusculas 
curso.lower()
'ensino a dist√¢ncia'

# SPLIT() Quebra a string em substrings. 
curso.split()
['Ensino', 'a', 'Dist√¢ncia']

# x in s -	True se x for um subconjunto de s
#x not in s	- False se x for um subconjunto de s
#s + t	- Concatena√ß√£o de s e t
#n*s -	Concatena√ß√£o de n c√≥pias de s
#s[i] -	Caractere de √≠ndice i em s
#len(s) -	Comprimento de s
#min(s)	- Menor item de s
#max(s)	- Maior item de s 

# Dicion√°rios 
{<chave 1>:<valor 1>, <chave 2>:<valor 2>, ..., <chave i>:<valor i>}
telefones = {'1': [ "Humberto", "Henrique", "5555-5555"], '2': ["Jo√£o", "Silva", "5555-5555"]}
telefones['1'] ['Humberto', 'Henrique', '5555-5555']
telefones ['2'] ['Jo√£o', 'Silva', '5555-5555']


#[express√µes ...]	- Defini√ß√£o de lista
#x[ ], x[√≠ndice : √≠ndice]	- Operador de indexa√ß√£o
#**	- Exponencia√ß√£o
#+x, -x	- Sinal de positivo e negativo
#*, /, //, %	- Produto, divis√£o, divis√£o inteira, resto
#+, -	- Soma, subtra√ß√£o
#in, not in, <, <=, >, >=, <>, !=, ==	- Compara√ß√µes, inclusive a ocorr√™ncia em listas
#not x	- Booleano NOT (n√£o)
#and	- Booleano AND (e)
#or	- Booleano OR (ou) 
#Realizar opera√ß√µes alg√©bricas fun√ß√£o eval() em conjunto com a input(). """
numero = eval(input('Entre com um numero inteiro: ')) 
numero = numero +2 
print(numero)

#Exemplo IMC (√≠ndice de massa corp√≥rea)  """ 
 peso = eval(input('Entre com seu peso: '))
 altura = eval(input('Entre com sua altura: '))
 imc = peso/altura**2
 print('IMC= ', imc)

#Sa√≠da formatada de dados: fun√ß√£o print() com o separador exemplos: """"
  print(str(hora) + ' : ' + str(minutos) + ' : ' + str(segundos))
print('{} : {} : {} '.format(hora, minutos, segundos))
print(f'{hora} : {minutos} : {segundos} ')

#especificar a largura de campo para exibir um inteiro """ 
'{:4}, {:5}.format(10,100)' 10, 100 # 4 espa√ßos com {:4} (2 foram ocupados e 2 ficaram em branco), e que a segunda vari√°vel deveria ser impressa com 5 espa√ßos com {:5} (3 foram ocupados e 2 ficaram em branco).

#O m√©todo format() para imprimir valores de ponto flutuante com a precis√£o definida  
'{:8.5}'.format(10/3) '3.333'
# o usar {:8.5}, estamos determinando que a impress√£o ser√° com 8 espa√ßos, mas apenas 5 ser√£o utilizados.

#Impress√£o de sequ√™ncias printf() /  fun√ß√£o print() passando como par√¢metro a sequ√™ncia.
seq = [ 0,1,2]
print(seq)
[0,1,2]

#string como lida da direita para a esquerda utilizar [: : -1] 
print(str[::-1])
dlroW olleh
print(str[8:2:-1])
row ol

#Saida formatada de Dados com variaveis

# Todo Input √© tratado como String

X = input("Entre com seu nome: ")
X = " O nome informado foi " + X
print(X)
Run: Entre com seu nome: Fulanodetal
O nome informado foi Fulanodetal

X = input("Entre com seu nome: ")
print('O nome informado foi {}'.format(X))
Run: Entre com seu nome: Fulanodetal
O nome informado foi Fulanodetal

#Com duas vari√°veis
nomepai = input("Entre com seu nome: ")
nomefilha = input("Entre com o nome da filha: ")
print('O pai de {} √© {}'.format(nomefilha,nomepai))
Entre com seu nome: fulano
Entre com o nome da filha: beltrano
O pai de beltrano √© fulano

#Outra forma
nomepai = input("Entre com seu nome: ")
nomefilha = input("Entre com o nome da filha: ")
print(f'O pai de {nomefilha} √© {nomepai}')
Entre com seu nome: fulano
Entre com o nome da filha: beltrano
O pai de beltrano √© fulano

#Nos caso de numero inteiro utilizar Eval
x = eval(input("Entre com a sua idade: "))
X +=1
print(X)

#IF, ELIF E ELSE 
   if <condi√ß√£o 1>:
2     Bloco de c√≥digo que ser√° executado caso condi√ß√£o seja True
3     elif <condi√ß√£o 2>:
4     Bloco de c√≥digo que ser√° executado caso condi√ß√£o 1 seja False e condi√ß√£o 2 seja True
5     else:
6     Bloco de c√≥digo que ser√° executado caso condi√ß√£o 1 seja False e condi√ß√£o 2 seja False
7     Instru√ß√£o fora do if

#exemplo SE <5 (IF), SE FOR ==5 (ELIF) SE N√ÉO (ELSE)
 idade = eval(input('Informe a idade da crian√ßa: '))
  2 if idade < 5:
  3 print('A crian√ßa deve ser vacinada contra a gripe.')
  4 print('Procure o posto de sa√∫de mais pr√≥ximo.')
  5 elif idade == 5:
  6 print('A vacina estar√° dispon√≠vel em breve.')
  7 print('Aguarde as pr√≥ximas informa√ß√µes.')
  8 else:
  9 print('A vacina√ß√£o s√≥ ocorrer√° daqui a 3 meses.')
10  print('Informe-se novamente neste prazo.')
11 print('Cuide da sa√∫de sempre. At√© a pr√≥xima.')

#listas do tipo range() Simples
range(3) cria a sequ√™ncia (0, 1, 2).

#N√£o iniciadas em 0 
range(2, 7)  cria a sequ√™ncia (2, 3, 4, 5, 6)

#indicando inicio, fim e passo
range(2, 9, 3) cria a sequ√™ncia (2, 5, 8).

for letra in nome:
    print(letra)

 #O la√ßo for com uma string   
Entre com seu nome: >? jefferson
j
e
f
f
e
r
s
o
n

#Uso do la√ßo for com qualquer sequ√™ncia
nomes = ['Laura', 'Lis', 'Guilherme', 'Enzo', 'Arthur']
for nome in nomes:
    print(nome)
Laura
Lis
Guilherme
Enzo
Arthur

#IF, ELSE E RANGE DENTRO DO FOR
for numero in range(1,11,1):
    if numero%2 == 0:
        print(f'{numero} √© par  ')
    else:
        print (f'{numero} √© impar')   
1 √© impar
2 √© par  
3 √© impar
4 √© par  
5 √© impar
6 √© par  
7 √© impar
8 √© par  
9 √© impar
10 √© par  


#Estrutura de repeti√ß√£o while
palavra = input('Entre com uma palavra: ')
while palavra != 'sair':
    palavra = input('Digite sair para encerrar o la√ßo: ')
print('Voc√™ digitou sair e agora est√° fora do la√ßo')

#O la√ßo while infinito
while True:
 Bloco que ser√° repetido indefinidamente


#Auxiliares break, continue e pass
  while True:
2 print('Voc√™ est√° no primeiro la√ßo.')
3 opcao1 = input('Deseja sair dele? Digite SIM para isso. ')
4 if opcao1 == 'SIM':
5 break # este break √© do primeiro la√ßo
6 else:
7 while True:
8 print('Voc√™ est√° no segundo la√ßo.')
9 opcao2 = input('Deseja sair dele? Digite SIM para isso. ')
10 if opcao2 == 'SIM':
11 break # este break √© do segundo la√ßo
12 print('Voc√™ saiu do segundo la√ßo.')
13 print('Voc√™ saiu do primeiro la√ßo')


# Instru√ß√£o continue
for num in range(1, 11):
2 if num == 5:
3 continue
4 else:
5 print(num)
6 print('La√ßo encerrado')
1
2
3
4
La√ßo encerrado


#Instru√ß√£o pass
for num in range(1, 11):
2 if num % 2 == 0:
3 pass
4 else:
5 print(num)
6 print('La√ßo encerrado')
1
3
5
7
9
La√ßo encerrado

#Importar m√≥dulo
import nome_modulo
#Chamar a fun√ß√£o desejada, precedida do nome do m√≥dulo, com a instru√ß√£o:
nome_modulo.nome_funcao(param√™tros)

math
usado para opera√ß√µes matem√°ticas.
random
usado para gerar n√∫meros pseudoaleat√≥rios
smtplib
usado para permitir envio de e-mails
time
usado para implementar contadores temporais.
tkinter
usado para desenvolver interfaces gr√°ficas.

MATH
Fun√ß√£o	    Retorno
sqrt(x)	- Raiz quadrada de x
ceil(x)	- Menor inteiro maior ou igual a x
floor(x) - Maior inteiro menor ou igual a x
cos(x) - Cosseno de x
sin(x) - Seno de x
log(x, b) - Logaritmo de x na base b
pi - Valor de Pi (3.141592...)
e - Valor de e (2.718281...)

Distribui√ß√µes de valores reais m√≥dulo random.
Fun√ß√£o	            Retorno
random() - 	        N√∫mero de ponto flutuante no intervalo [0.0, 1.0)
uniform(a, b) -     N√∫mero de ponto flutuante N tal que a ‚â§ N ‚â§ b
gauss(mu, sigma) -  Distribui√ß√£o gaussiana. mu √© a m√©dia e sigma √© o desvio padr√£o.
normalvariate(mu, sigma) - Distribui√ß√£o normal. mu √© a m√©dia e sigma √© o desvio padr√£o

Fun√ß√µes para n√∫meros inteiros m√≥dulo random.
Fun√ß√£o	            Retorno
randrange(stop) / randrange(start, stop [,step]) -   Um elemento selecionado aleat√≥rio de range(start, stop, step), mas sem construir um objeto range.
randint(a, b) -     N√∫mero inteiro N tal que a ‚â§ N ‚â§ b

Fun√ß√µes para sequ√™ncias m√≥dulo random.
Fun√ß√£o                      	Retorno
choice(seq) -	Elemento aleat√≥rio de uma sequ√™ncia n√£o vazia seq.
shuffle(x[, random]) -	Embaralha a sequ√™ncia x no lugar.
sample(pop, k) - Uma sequ√™ncia de tamanho k de elementos escolhidos da popula√ß√£o pop, sem repeti√ß√£o. Usada para amostragem sem substitui√ß√£o.

M√≥dulo time
Fun√ß√£o	Retorno
time()	N√∫mero de segundos passados desde o in√≠cio da contagem (epoch). Por padr√£o, o in√≠cio √© 00:00:00 do dia 1 de janeiro de 1970.
ctime(segundos)	Uma string representando o hor√°rio local, calculado a partir do n√∫mero de segundos passado como par√¢metro.
gmtime(segundos)	Converte o n√∫mero de segundos em um objeto struct_time descrito a seguir.
localtime(segundos)	Semelhante √† gmtime(), mas converte para o hor√°rio local.
sleep(segundos)	A fun√ß√£o suspende a execu√ß√£o por determinado n√∫mero de segundos.

Fun√ß√£o  time() e ctime().
 x = time.time()
>>> print(f'Local time: {time.ctime(x)}')
Local time: Tue Jun 30 23:38:55 2020
 
 Pacotes Externos:
Nome do m√≥dulo	    Para que serve?
numpy	C√°lculos -  opera√ß√µes matem√°ticas e simula√ß√µes
pandas  -          	Manipula√ß√£o de dados
scikit-learn	-   Modelos de aprendizado de m√°quina
matplotlib  -	Visualiza√ß√£o de dados
requests    -	Biblioteca de comandos de comunica√ß√£o pelo protocolo HTTP
flask   -	Constru√ß√£o de aplica√ß√µes web

Exce√ß√£o	                            Explica√ß√£o
KeyboardInterrupt   -	Levantado quando o usu√°rio pressiona CTRL + C, a combina√ß√£o de interrup√ß√£o.
OverflowError   -	Levantado quando uma express√£o de ponto flutuante √© avaliada como um valor muito grande.
ZeroDivisionError	-   Levantado quando se tenta dividir por 0.
IOError -   	Levantado quando uma opera√ß√£o de entrada/sa√≠da falha por um motivo relacionado a isso.
IndexError  -  	Levantado quando um √≠ndice sequencial est√° fora do intervalo de √≠ndices v√°lidos.
NameError   -	Levantado quando se tenta avaliar um identificador (nome) n√£o atribu√≠do.
TypeError   -	Levantado quando uma opera√ß√£o da fun√ß√£o √© aplicada a um objeto do tipo errado.
ValueError  -	Levantado quando a opera√ß√£o ou fun√ß√£o tem um argumento com o tipo correto, mas valor incorreto.

__init__() serve para inicializa√ß√£o de classes: 
class Conta:
def__init__(self, numero, cpf, nomeTitular, saldo):
self.numero = numero
self.cpf = cpf
self.nomeTitular = nomeTitular
self.saldo = saldo

classe sem um m√©todo construtor:
class A():
def f():
print ‚Äòfoo‚Äô

m√©todo decorator @property:
@property
def saldo(self):
return self._saldo

Os m√©todos decorados com a property @setter for√ßam que todas altera√ß√µes de valor dos atributos privados devem passar por esses m√©todos.
@saldo.setter
def saldo(self, saldo):
if (self.saldo < 0):
print(‚Äúsaldo inv√°lido‚Äù)
else:
self._saldo = saldo 

m√©todo como est√°tico, deve-se usar o decorator @classmethod
Em (1), √© criado o par√¢metro cls como refer√™ncia para classe.
Em (2), √© retornado o valor do atributo de classe _total_circulos.
class Circulo:
_total_circulos = 0
def__init__(self,pontox, pontoy, raio):
self.pontox = pontox
self.pontoy = pontoy
self.raio = raio
type(self)._total_circulos +=1
@classmethod
def get total_circulos(cls): (1)
return cls.total_circulos (2)

m√©todos est√°ticos 
 import math
class Math:
@staticmethod
def sqrt(x):
return math.sqrt(x)
Math.sqrt(20)
4.47213595499958

Os dois underscores antes do m√©todo indicam que ele √© privado:
m√©todo geralsaldo como privado
  
class Circulo:
def__init__(self,clientes,numero,saldo):
self.clientes = clientes
self.numero = numero
self.saldo = saldo
def __gerarsaldo(self):
print(f"numero: {self.numero}\n saldo:{self.saldo}")


        Instancia√ß√£o de objetos
                                            Linguagens
                                        Java	C++	    Python
Instancia√ß√£o de objetos                 X        X         X
Construtores de objetos                 X        X         X
Modificadores de acesso atributos       X        X         X(*)
Modificadores de acesso m√©todos         X        X         X
Heran√ßa m√∫ltipla                                 X         X           
Classes informais                                X         X 
Tipos primitivos                        X        X 
Interfaces                              X        X 
Sobrecarga de m√©todos                   X        X 

Exemplo fun√ß√µes de ordem superior (higher order function).

def multiplicar_por(multiplicador):
    def multi(multiplicando):
    return multiplicando * multiplicador
    return multi
    multiplicar_por_10 = multiplicar_por(10)
    print(multiplicar_por_10(1))
    print(multiplicar_por_10(2)) 
    multiplicar_por_5 = multiplicar_por(5)
    print(multiplicar_por_5(1))
    print(multiplicar_por_5(2))

Exemplo que calcula o valor de um taximetro:
def taximetro(distancia):
    def calculaMult():
        if distancia < 5:
            return 1.2
        else:
            return 1
    multiplicador = calculaMult()
    largada = 3
    km_rodado = 2
    valor = (largada + distancia * km_rodado) * multiplicador
    return valor


dist = eval(input("Entre com a distancia a ser percorrida em km: "))
pagamento = taximetro(dist)
print(f'O valor a pagar √© R$ {pagamento}')

 Lista valores como argumento para a fun√ß√£o altera_lista
 
 valores = [10, 20, 30] 
    def altera_lista(lista):
    lista[2] = lista[2] + 10
    return lista
    print("Nova lista", altera_lista(valores))
    print("Nova lista", altera_lista(valores))

valores = [10, 20, 30] 
    def altera_lista(lista):
    nova_lista = list(lista)
    nova_lista[2] = nova_lista[2] + 10
    return nova_lista
    print("Nova lista", altera_lista(valores))
    print("Nova lista", altera_lista(valores))

Fun√ß√µes puras - dependem apenas dos par√¢metros de entrada para gerar uma sa√≠da
    
    valor = 20
    def multiplica(fator):
    global valor
    valor = valor * fator
    print("Resultado", valor)
    multiplica(3)
    multiplica(3)

valor = 20
    def multiplica(valor, fator):
    valor = valor * fator
    return valor 
    print("Resultado", multiplica(valor, 3))
    print("Resultado", multiplica(valor, 3))

Fun√ß√µes lambda - fun√ß√µes an√¥nimas / lambda argumentos: express√£o

def multiplicar_por(multiplicador):
    return lambda multiplicando: multiplicando * multiplicador
    multiplicar_por_10 = multiplicar_por(10)
    print(multiplicar_por_10(1))
    print(multiplicar_por_10(2))    
    multiplicar_por_5 = multiplicar_por(5)
    print(multiplicar_por_5(1))
    print(multiplicar_por_5(2))

    def multiplicar_por(multiplicador):
    def multi(multiplicando):
    return multiplicando * multiplicador
    return multi
    multiplicar_por_10 = multiplicar_por(10)
    print(multiplicar_por_10(1))
    print(multiplicar_por_10(2))
    multiplicar_por_5 = multiplicar_por(5)
    print(multiplicar_por_5(1))
    print(multiplicar_por_5(2))

fun√ß√£o map √© pura e de ordem superior - map(fun√ß√£o, iter√°vel1, iter√°vel2...)

lista = [1, 2, 3, 4, 5] 
    def triplica_itens(iterable): ## recebe um iter√°vel como par√¢metro
    lista_aux = []   ## cria uma lista auxiliar para garantir imutabilidade
    for item in iterable: ## percorre os itens do iter√°vel passado como par√¢metro 
    lista_aux.append(item*3) ## adiciona os itens triplicados √† lista auxiliar
    return lista_aux  ##retorna a lista auxiliar
    nova_lista = triplica_itens(lista) ##Essa fun√ß√£o √© chamada com o argumento lista 
    print(nova_lista)  ##resultado √© impresso 

    lista = [1, 2, 3, 4, 5]
    def triplica(item): ## triplica e retorna o item passado como par√¢metro 
    return item * 3  ## triplica e retorna o item passado como par√¢metro 
    nova_lista = map(triplica, lista) ##√â utilizada, assim como a vari√°vel lista, como argumentos para a fun√ß√£o map 
    print(list(nova_lista)) ##O resultado da fun√ß√£o map √© armazenado na vari√°vel nova_lista

    lista = [1, 2, 3, 4, 5]
    nova_lista = map(lambda item: item * 3, lista)
    print(list(nova_lista))

Filter - utilizada para filtrar elementos de um iter√°vel (lista, tupla, dicion√°rios etc.)
sintaxe - filter(fun√ß√£o, iter√°vel)

lista = [1, 2, 3, 4, 5]
    def impares(iterable): ##par√¢metro
    lista_aux = [] ## lista auxiliar para garantir imutabilidade
    for item in iterable: ## percorre os itens do iter√°vel passados como par√¢metros
    if item % 2 != 0: ## adiciona os itens √≠mpares √† lista auxiliar
    lista_aux.append(item) ## adiciona os itens √≠mpares √† lista auxiliar
    return lista_aux  ## retorna a lista auxiliar
    nova_lista = impares(lista)
    print(nova_lista)

lista = [1, 2, 3, 4, 5]
    def impar(item): ##retorna true se o item passado como par√¢metro √© √≠mpar ou false caso contr√°rio
    return item % 2 != 0    
    nova_lista = filter(impar, lista)
    print(list(nova_lista))

lista = [1, 2, 3, 4, 5]
    nova_lista = filter(lambda item: item % 2 != 0, lista)
    print(list(nova_lista))


Cria√ß√£o de thread e um processo que executam a mesma fun√ß√£o
from threading import Thread
    from multiprocessing import Process
    def funcao_a(nome):
    print(nome) 
    if __name__ == '__main__':
    t = Thread(target=funcao_a, args=("Minha Thread",))
    t.start()
    p = Process(target=funcao_a, args=("Meu Processo",))
    p.start()

    Minha Thread
    Meu Processo
    Process finished with exit code 0


 cria√ß√£o de m√∫ltiplas threads e processos
from threading import Thread, Lock
    from multiprocessing import Process
    import time
    minha_lista = []
    def funcao_a(indice):
    for i in range(100000):
    minha_lista.append(1)
    print("Termino thread ", indice)
    if __name__ == '__main__':
    tarefas = []
    for indice in range(10):
    tarefa = Thread(target=funcao_a, args=(indice,))
    tarefas.append(tarefa)
    tarefa.start()
    print("Antes de aguardar o termino!", len(minha_lista))
    for tarefa in tarefas:
    tarefa.join()
    print("Ap√≥s aguardar o termino!", len(minha_lista))

from threading import Thread, Lock
    from multiprocessing import Process
    import time
    minha_lista = []
    def funcao_a(indice):
    for i in range(100000):
    minha_lista.append(1)
    print("Termino processo ", indice)
    if __name__ == '__main__':
    tarefas = []
    for indice in range(10):
    tarefa = Process(target=funcao_a, args=(indice,))
    tarefas.append(tarefa)
    tarefa.start()
    print("Antes de aguardar o termino!", len(minha_lista))
    for tarefa in tarefas:
    tarefa.join()
    print("Ap√≥s aguardar o termino!", len(minha_lista))

Termino thread Termino thread 0 1
    Termino thread Termino thread 23Termino thread 4
    Termino thread 5
    Termino thread 6
    Termino thread 7
    Termino thread Antes de guardar o termino! Termino thread 9
    970012
    8 
    Apos guardar o termino! 1000000
    Process finished with exit code 0

Antes guardar o termino! 0
    Termino thread 0
    Termino thread 2
    Termino thread 1
    Termino thread 4
    Termino thread 3
    Termino thread 5
    Termino thread 7
    Termino thread 6
    Termino thread 8
    Termino thread 9
    Apos guardar o termino! 0
    Process finished with exit code 0

Travas (Lock)

from threading import Thread, Lock
    from multiprocessing import Process
    import time
    contador = 0
    def funcao_a(indice):
    global contador
    for i in range(1000000):
    contador += 1
    print("Termino thread ", indice)
    if __name__ == '__main__':
    tarefas = []
    for indice in range(10):
    tarefa = Thread(target=funcao_a, args=(indice,))
    tarefas.append(tarefa)
    tarefa.start()
    print("Antes de aguardar o termino!", contador) 
    for tarefa in tarefas:
    tarefa.join()
    print("Ap√≥s aguardar o termino!", contador)
  
Termino thread 1
    Termino thread Termino thread 3 2
    Termino thread 0 Termino thread
    Antes de aguardar o termino! Termino thread 4
    5Termino thread 6
    2235554
    Termino thread Termino thread 9
    Termino thread 7
    8
    Apos aguardar o termino! 3316688    
    Process finished with exit code 0


from threading import Thread, Lock
    from multiprocessing import Process
    import time 
    contador = 0
    lock = Lock()  ## vari√°vel global lock
    print_lock = Lock()
    def funcao_a(indice):
    global contador
    for i in range(1000000):
    lock.acquire()
    contador += 1   ## opera√ß√£o de incremento 
    lock.release() ## liberamos a trava utilizando o m√©todo release 
    print_lock.acquire()   ## m√©todo acquire() da vari√°vel lock (linha 12)
    print("Termino thread ", indice)
    print_lock.release()
    if __name__ == '__main__':
    tarefas = []
    for indice in range(10):
    tarefa = Thread(target=funcao_a, args=(indice,))
    tarefas.append(tarefa)
    tarefa.start()
    print("Antes de aguardar o termino!", contador) 
    for tarefa in tarefas:
    tarefa.join()
    print("Ap√≥s aguardar o termino!", contador)

Antes de aguardar o termino! 73844
    Termino thread 1
    Termino thread 7
    Termino thread 8
    Termino thread 9
    Termino thread 2
    Termino thread 3
    Termino thread 0
    Termino thread 4
    Termino thread 6
    Termino thread 5
    Ap√≥s aguardar o termino! 10000000 
    Process finished with exit code 0

Vari√°vel do tipo inteiro e compartilh√°-la entre os processos. Essa vari√°vel far√° o papel de um contador e a fun√ß√£o paralelizada vai increment√°-la.

from threading import Thread
    from multiprocessing import Process, Value 
    def funcao_a(indice, cont):
    for i in range(100000):
    with cont.get_lock():
    cont.value += 1
    print("Termino processo ", indice) 
    if __name__ == '__main__':
    contador = Value('i', 0)  ##Declaramos uma vari√°vel chamada contador utilizando o construtor da classe value, onde passamos como primeiro argumento um caractere com o tipo da vari√°vel compartilhada (‚Äòi‚Äô ü°™ inteiro) e seu valor inicial (0)
    tarefas = []
    for indice in range(10):
    tarefa = Process(target=funcao_a, args=(indice, contador)) ## par√¢metro indice da funcao_a recebe o valor da vari√°vel √≠ndice e o par√¢metro cont recebe uma refer√™ncia para a vari√°vel contador
    tarefas.append(tarefa)
    tarefa.start()
    print("Antes de aguardar o termino!", contador.value) 
    for tarefa in tarefas:
    tarefa.join()
    print("Ap√≥s aguardar o termino!", contador.value)

Antes de aguardar o termino! 0
    Termino processo 2
    Termino processo 1
    Termino processo 0
    Termino processo 3
    Termino processo 4
    Termino processo 5  
    Termino processo Termino processo 7
    6
    Termino processo 8
    Termino processo 9
    Ap√≥s aguardar o termino! 1000000
    Process finished with exit code 0

Utilizando o framework  Flask. 
Aplica√ß√£o web b√°sica que retorna ‚ÄúOl√°, mundo.‚Äù script √© flask1.py http://127.0.0.1:5000 :
    from flask import Flask
app = Flask(__name__) 
@app.route('/')
def ola_mundo():
return "Ol√°, mundo."
if __name__ == '__main__':
app.run()
Serving Flask app "principal" (lazy loading)
Enviroment: production
WARNING: This is a development server. Do not use it in a production deployment.
Use a production WSGI server instead.
Debug mode: off
Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)

Alterando http://127.0.0.1:5000 por http://127.0.0.1:5000/ola : 
from flask import Flask
app = Flask(__name__)
@app.route('/ola')
def ola_mundo():
return "Ol√°, mundo."
if __name__ == '__main__':
app.run()

Rota para a URL raiz da aplica√ß√£o (@app.route(‚Äò/‚Äô)).
from flask import Flask 
app = Flask(__name__) 
@app.route('/')
def index():
return "P√°gina principal."
@app.route('/ola')
def ola_mundo():
return "Ol√°, mundo."
if __name__ == '__main__':
app.run()

Mudando a rota da fun√ß√£o ola_mundo de forma que seja poss√≠vel capturar e retornar o nome passado como par√¢metro.
from flask import Flask
app = Flask(__name__)
@app.route('/')
def index():
return "P√°gina principal."
@app.route('/ola/<nome>')
def ola_mundo(nome):
return "Ol√°, " + nome
if __name__ == '__main__':
app.run()

Rota deve responder √†s requisi√ß√µes do tipo GET e POST.
from flask import Flask 
app = Flask(__name__)
app.debug = True
@app.route('/')
def index():
return "P√°gina principal."
@app.route('/ola/')
@app.route('/ola/<nome>')
def ola_mundo(nome):
return "Ol√°, " + nome
@app.route('/logar', methods=['GET', 'POST'])
def logar():
if request.method == 'POST':
return "Recebeu post! Fazer login!"
else:
return "Recebeu get! Exibir FORM de login."
if __name__ == '__main__':
app.run()
##Para verificar o m√©todo que foi utilizado na requisi√ß√£o, usamos o atributo method do objeto request, que retorna uma das strings: GET, POST, PUT ou DELETE.
##As aplica√ß√µes web disponibilizam diversos m√©todos para acessar uma URL: GET, POST, PUT e DELETE. Por padr√£o, as rotas do Flask somente respondem √†s requisi√ß√µes GET. Para responder a outros m√©todos, √© necess√°rio explicitar, na rota, quais m√©todos ser√£o aceitos.
Express√µes: {{ ... }} - Serve para escrever algo no modelo, como o valor de uma vari√°vel.
Declara√ß√µes: {% ... %} - Utilizado em la√ßos e condicionantes, por exemplo.

Para passar a vari√°vel nome para o HTML, precisamos chamar a fun√ß√£o render_template com um par√¢metro a mais
from flask import Flask, render_template 
app = Flask(__name__) 
@app.route('/')
def index():
return render_template('indice.html') 
@app.route('/ola/')
@app.route('/ola/<nome>')
def ola_mundo(nome="mundo"):
return "Ol√°, ", nome_recebido = nome 
if __name__ == '__main__':
app.run()
   Codigo 22 - Modelo ola.html
<!DOCTYPE html>
<html>
<body>
<h1>Ol√°, {{ nome_recebido }}</h1>
</body>
</html>

Neste exemplo, vamos utilizar uma s√©rie hist√≥rica fict√≠cia de casos de dengue de uma determinada cidade e, com o aux√≠lio 
do algoritmo supervisionado de regress√£o linear, predizer casos futuros.

import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
import pandas
############# Pr√©-processamento ###############
# Coleta e Integra√ß√£o
arquivo = pandas.read_csv('dados_dengue.csv')
anos = arquivo[['ano']]
casos = arquivo[['casos']]
############## Minera√ß√£o #################
regr = LinearRegression()
regr.fit(X=anos, y=casos)
ano_futuro = [[2018]]
casos_2018 = regr.predict(ano_futuro)
print('Casos previstos para 2018 ->', int(casos_2018))
############ P√≥s-processamento ################
plt.scatter(anos, casos, color='black')
plt.scatter(ano_futuro, casos_2018, color='red')
plt.plot(anos, regr.predict(anos), color='blue')
plt.xlabel('Anos')
plt.ylabel('Casos de dengue')
plt.xticks([2018])
plt.yticks([int(casos_2018)]) 
plt.show()
   Codigo 23 - Dados_dengue.csv
ano,casos
2017,450
2016,538
2015,269
2014,56
2013,165
2012,27
2011,156
2010,102
2009,86
2008,42
2007,79
2006,65
2005,58
2004,39
2003,23
2002,15
2001,28
## Sa√≠da do script regressao.py
1C:\Users\fotoli\PycharmProjects\estac
2Casos previstos para 2018 -> 330
##Ap√≥s importar os m√≥dulos necess√°rios, vamos passar para a primeira etapa do KDD, o pr√©-processamento. Neste caso simples, vamos realizar apenas a coleta e integra√ß√£o que, na pr√°tica, √© carregar a planilha dentro do programa.
##Para isso, utilizamos a fun√ß√£o read_csv da biblioteca Pandas, passando como par√¢metro o nome do arquivo (linha 7).

 Dois algoritmos de classifica√ß√£o, √°rvore de decis√£o e m√°quina de vetor suporte (suport vector machine ‚Äì SVM) 
 para montar dois classificadores de flores de √≠ris. 
##No total, s√£o quatro caracter√≠sticas para cada amostra, sendo elas o comprimento e a largura, em cent√≠metros, das s√©palas e p√©talas de rosas.
from sklearn.datasets import load_iris, fetch_kddcup99
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier, export_text, plot_tree
from sklearn.svm import SVC 
################## Pr√©-processamento ###################
# Coleta e Integra√ß√£o
iris = load_iris()
caracteristicas = iris.data
rotulos = iris.target
print("Caracteristicas:\n", caracteristicas[:2])
print("R√≥tulos:\n", rotulos[:2])
print('########################################################')
# Parti√ß√£o dos dados
carac_treino, carac_teste, rot_treino, rot_teste = train_test_split(caracteristicas, rotulos)
################### Minera√ß√£o ##################### 
############---------- Arvore de Decis√£o -----------############
arvore = DecisionTreeClassifier(max_depth=2)
arvore.fit(X=carac_treino, y=rot_treino)
rot_preditos = arvore.predict(carac_teste)
acuracia_arvore = accuracy_score(rot_teste, rot_preditos)
############-------- M√°quina de Vetor Suporte ------############
clf = SVC()
clf.fit(X=carac_treino, y=rot_treino) 
rot_preditos_svm = clf.predict(carac_teste)
acuracia_svm = accuracy_score(rot_teste, rot_preditos_svm)
################ P√≥s-processamento ####################
print("Acur√°cia √Årvore de Decis√£o:", round(acuracia_arvore, 5))
print("Acur√°cia SVM:", round(acuracia_svm, 5))
print('########################################################') 
r = export_text(arvore, feature_names=iris['feature_names'])
print("Estrutura da √°rvore")
print(r)
##Sa√≠da do script 
Caracteristicas:
[[5.1 3.5 1.4 0.2]
[4.9 3.  1.4 0.2]]
R√≥tulos:
[0 0]
###########################################
Acur√°cia √Årvore de Decis√£o: 0.92105
Acur√°cia SVM: 0.97368
###########################################
Estrutura da √°rvore
|--- petal width (cm) <= 0.80
|   |--- class: 0
|--- petal width (cm) > 0.80
|   |--- petal width (cm) <= 1.75
|   |   |--- class: 1
|--- petal width (cm) > 1.75
|   |   |--- class: 2
Process finished with exit code 0

##Na etapa de minera√ß√£o de dados, vamos treinar o algoritmo de agrupamento K-medias com as caracter√≠sticas das flores. Para isso, criamos uma inst√¢ncia da classe KMeans passando como par√¢metro o n√∫mero de grupos (ou classes) que desejamos que o algoritmo identifique (n_clusters) (linha 13).

Podemos utilizar o atributo labels_ do objeto grupos para retornar uma lista com o √≠ndice do grupo ao qual cada amostra pertence. Como o n√∫mero de grupos (n_clusters) √© 3, o √≠ndice varia entre: 0, 1 e 2.

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn.cluster import KMeans
from sklearn.datasets import load_iris
################## Pr√©-processamento ###################
# Coleta e Integra√ß√£o
iris = load_iris()
caracteristicas = iris.data
################### Minera√ß√£o #####################
grupos = KMeans(n_clusters=3)
grupos.fit(X=caracteristicas)
labels = grupos.labels_ # indice do grupo ao qual cada amostra pertence
################ P√≥s-processamento ####################
fig = plt.figure(1)
ax = Axes3D(fig)
ax.set_xlabel('Comprimento S√©pala')
ax.set_ylabel('Largura S√©pala')
ax.set_zlabel('Comprimento P√©tala')
ax.scatter(caracteristicas[:, 0], caracteristicas[:, 1], caracteristicas[:, 2], c=grupos.labels_, edgecolor='k')
target = iris.target
fig = plt.figure(2)
ax = Axes3D(fig)
ax.set_xlabel('Comprimento S√©pala')
ax.set_ylabel('Largura S√©pala')
ax.set_zlabel('Comprimento P√©tala')
ax.scatter(caracteristicas[:, 0], caracteristicas[:, 1], caracteristicas[:, 2], c=target, edgecolor='k')
plt.show()